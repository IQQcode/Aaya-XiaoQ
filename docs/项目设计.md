## 1. 研究背景与意义

苹果的一则广告曾有这样一句话：“你的下一个女朋友，何必是人类！“

语音助手的场景化解决方案将逐渐丰富，语音交互方式作为人机交互的重要演进方向，正逐步渗透到人们
的日常生活中，与各类型应用场景相结合。



## 2. 研究内容





## 3. 研究方法与思路

### 3.1 组件化

无论是后端的Web项目，还是移动端的APP，在复杂功能的项目中一定会存在多个模块。有对应的功能业务模块，还有对应的通用基础模块。针对于多功能多模块构建的APP项目，通用基础模块module_common，提供BaseActivity/BaseFragment、图片加载、网络请求等基础能力，然后每个业务模块都会依赖这个基础模块。例如 “首页”、“分类”、“发现”、“购物车”、“我的”，都是需要跳转到“商品详情” 的，必然是依赖“商品详情” ；而“商品详情”是需要能添加到“购物车”能力的；而“首页”点击搜索显然是“分类”中的搜索功能。所以这些**模块之间存在复杂的依赖关系**。

在后端Web开发中，我们会用MVC的分层架构，结合Spring IOC Bean 容器的来帮助我们创建管理对象，通过DI来将依赖的Bean进行注入；对于移动端项目来说，为了解决模块间的高度耦合，我们将每个业务模块拆分成为独立的App，模块可以拆分为基础组件和业务组件两大类。

**组件化带来的好处** 就显而易见了：

1. **加快编译速度**：每个业务功能都是一个单独的工程，可独立编译运行，拆分后代码量较少，编译自然变快。
2. **提高协作效率**：解耦 使得组件之间 彼此互不打扰，组件内部代码相关性极高。 团队中每个人有自己的责任组件，不会影响其他组件；降低团队成员熟悉项目的成本，只需熟悉责任组件即可；对测试来说，只需重点测试改动的组件，而不是全盘回归测试。
3. **功能重用**：组件 类似我们引用的第三方库，只需维护好每个组件，一建引用集成即可。业务组件可上可下，灵活多变；而基础组件，为新业务随时集成提供了基础，减少重复开发和维护工作量。

- [x] 页面跳转ARouter
- [ ] 组件间通信EventBus
- [ ] 集成到主APP



组件依赖关系是上层依赖下层，修改频率是上层高于下层。

**基础组件**是通用基础能力，修改频率极低，作为SDK可共公司所有项目集成使用。

**common组件**，作为支撑业务组件、业务基础组件的基础（BaseActivity/BaseFragment等基础能力），同时依赖所有的基础组件，提供多数业务组件需要的基本功能，并且统一了基础组件的版本号。所以 业务组件、业务基础组件 所需的基础能力只需要依赖common组件即可获得。

**业务组件**、**业务基础组件**，都依赖common组件。但**业务组件之间不存在依赖关系**，业务基础组件之间不存在依赖关系。而 业务组件 是依赖所需的业务基础组件的，例如几乎所有业务组件都会依赖广告组件 来展示Banner广告、弹窗广告等。

最上层则是主工程，即所谓的“**壳工程**”，主要是集成所有的业务组件、提供Application唯一实现、gradle、manifest配置，整合成完备的App。

> https://juejin.cn/post/6881116198889586701

### 3.2 系统架构设计

本系统APP基于百度AI打造一款集WakeUp，TTS，ASR为一体的智能服务类助手APP，基于组件化思想构建项目，根据组件的不同功能抽象出不同的组件层级结构。主工程APP作为空壳工程来对整个子模块进行管理，通过Kotlin Gradle DSL来编写buildSrc模块，管理整个工程依赖的类库，同时，全局变量 isApp来设置每个Module是否是独立的APP，管理每个模块是作为Library还是Application集成到主工程APP下。本语音助手系统总业务架构设计如图4-1所示。

常规业务组件就是本助手APP下的9个功能模块，分别为应用管理、智能聊天、星座、开发者模式、笑话、系统设置、语音设置、天气。

 核心管理组件为ARouter路由跳转，负责从主工程APP下跳转到各个模块的Activity；Service语音的生命周期管理，负责管理TTS、ASR、Wake UP的初始化及监听操作，是语音交互的主要管理类。

公共层存放三大核心管理组件，分别为Base公共基础类，Network网络请求及Voice语音引擎分析组件。Base公共基础类下包含组件间通信EventBus、路由管理、实体类、工具类及BaseActivity基类和初始化服务；Network网络请求使用OkHttp3和Retrofit2两个开源的网络请求库；Voice下是对语音的管理，包含TTS、ASR、Wake UP、关键词的初始化及封装，供功能模块调用。

基础层是Android常用的UI控件封装，日志管理，自定义组件的使用。多处用到了自定义RecyclerView、ListView，WebView以及ViewPager等组件来搭建页面；APP启动后可查看各个关键功能点的日志，方便分析和定位问题。



-------------

### 3.3 语音交互设计





---------------

### 3.4 Service保活

**语音功能，做的更多的是保障语音能够实时进行识别**。

当应用APP从前台置位后台，状态由onResume到onStop的状态，虽然被置位后台Task栈不可与Activity直接交互，但是其Service仍在后台。但是，当系统开启新的进程任务而检测到内存不足时，Android会杀掉后台应用进程，服务一旦停止，就无法通过语音交互。

如何做到像内置的手机语音助手那样，随时随地能够唤醒成功？就需要考虑对Service进行保活

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img-2021-befo/20210606073457.png)

原理就是利用 Binder 的讣告机制，如果 Service Binder 实体的进程被杀，系统会向 Client 发送讣告，这个时机就是保活的空子了。所以可以通过两个进程启动两个 Binder 服务，互为 C/S，一旦一个进程挂掉，另一个进程就会收到 Binder 讣告，这时可以拉起另一个进程。

那么图中两个进程中的 TransferActivity 是干什么用的 ，这个在后面再说。

这里我写了两个应用，一个是 AIDLServer，相当于服务端；一个是 AIDLClient，相当于客户端。而两个进程之间的通信采用 AIDL 方式。注意两个应用的 AIDL 文件必须一致，包括包名。

然后，编写两个 binder 实体服务 RemoteService 、LocalService。在 onCreate 的时候相互绑定，并在 onServiceDisconnected 收到讣告的时候，重新启动服务绑定彼此即可。

通过 TransferActivity 中转下，先启动守护进程的 TransferActivity，再从守护进程的 TransferActivity 中启动保活进程的 TransferActivity，这是没有问题的，再从保活进程的 TransferActivity 中启动 LocalService，重新绑定服务即可，反过来也是一样的。当然，TransferActivity 要用户无感知，不然会很突兀，所以这里的 TransferActivity 都是 1 个像素，做完任务及时销毁即可。

> https://wuzhangyang.com/2018/11/27/android-keep-alive/

**前台服务（Foreground Service） +  全局通知（notification）**

前台服务（Foreground Service）相比起后台服务（Service）,拥有一个优势那就是在系统内存不足的时候不允许系统杀死的服务，并且在运行时需要能被用户所知，需要在状态栏创建一个通知来管理。

全局通知（notification），常用于告知用户某些事件在某个事件发生，在发动时会在状态栏和通知栏都显示信息，用户可以点击信息进行某些功能的管理

> https://blog.csdn.net/ex_xyz/article/details/109258577

### 3.5 功能模块设计

